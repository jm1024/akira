#!/usr/bin/env python3
import telnetlib
import time
import argparse
import sys
import os
import json
import signal

import sidraCore

PORT = 23

USERNAME = "admin"
PASSWORD = "admin"

DEBUG = True

name = ""
lane = ""
ip = ""
state = {}

tnConn = None


#############################
def readUntil(tn, marker, timeout=5):
    """Read until marker bytes are seen or timeout expires."""
    if DEBUG:
        print(f"readUntil({marker!r})")
    data = tn.read_until(marker.encode("ascii"), timeout)
    if DEBUG and data:
        try:
            print("<<", data.decode(errors="ignore"))
        except Exception:
            print("<<", data)
    return data


#############################
def sendLine(tn, line):
    """Send a line terminated with CRLF."""
    msg = (line + "\r\n").encode("ascii")
    if DEBUG:
        print(">>", msg)
    tn.write(msg)


#############################
def login(tn):
    # Wait for "User Name:" prompt
    readUntil(tn, "User Name:", timeout=5)

    # Send username
    sendLine(tn, USERNAME)

    # Wait for "Password:" prompt
    readUntil(tn, "Password:", timeout=5)

    # Send password
    sendLine(tn, PASSWORD)

    # Read a little bit of what comes next
    time.sleep(0.2)
    data = tn.read_very_eager()
    text = data.decode(errors="ignore") if data else ""

    if DEBUG and text:
        print("LOGIN RESPONSE RAW:\n", text)

    if "Access denied" in text:
        print("LOGIN FAILED (Access denied)")
        raise SystemExit(1)

    # If no explicit error, treat as success
    print("Logged in OK")


#############################
def setAllInputsAndNotify(tn):
    """
    - iomask: affect all 16 bits
    - iodir: 1 = input, so ffff = all inputs
    - readall once (and set initial global state)
    - enable notifications
    """
    global state

    # iomask: affect all 16 bits
    sendLine(tn, "gpio iomask ffff")
    time.sleep(0.1)
    tn.read_very_eager()

    # iodir: 1 = input, so ffff = all inputs
    sendLine(tn, "gpio iodir ffff")
    time.sleep(0.1)
    tn.read_very_eager()

    # initial read
    sendLine(tn, "gpio readall")
    time.sleep(0.1)
    resp = tn.read_very_eager()

    if resp:
        text = resp.decode(errors="ignore").strip()
        if DEBUG:
            print("READALL:\n", text)

        parsed = parseGpio(text)
        if parsed is not None:
            state = parsed
            if DEBUG:
                print(state)

    # enable notifications
    sendLine(tn, "gpio notify on")
    time.sleep(0.1)
    tn.read_very_eager()

#############################
def monitorNotifications(tn):
    
    global state
    
    print("Monitoring GPIO")
    try:
        while True:
            # read one line-ish at a time
            data = tn.read_until(b"\n", timeout=1)
            if not data:
                continue
            text = data.decode(errors="ignore").strip()
            if not text:
                continue
            state = parseGpio(text)
            print(state)
            #print("EVENT RAW:", text)
    except Exception as ex:
        print("Exception in monitorNotification: " + str(ex))

#############################
def parseGpio(text):
    """
    Parse either:
      - notify line: '# FFFF FEFF FFFF'
      - readall result: 'FEFF', '>>FEFF', etc.
    Returns dict: {'100':1, ..., '115':0} or None on failure.
    """
    text = text.strip()
    if not text:
        return None

    parts = text.split()
    if not parts:
        return None

    hexChars = "0123456789ABCDEFabcdef"
    hexVal = None

    # Case 1: notification line like '# FFFF FEFF FFFF'
    if parts[0] == "#" and len(parts) >= 3:
        candidate = "".join(c for c in parts[2] if c in hexChars)
        if candidate:
            hexVal = candidate

    # Case 2: readall or anything else: first token that has any hex in it
    if hexVal is None:
        for p in parts:
            candidate = "".join(c for c in p if c in hexChars)
            if candidate:
                hexVal = candidate
                break

    if hexVal is None:
        if DEBUG:
            print("parseGpio: no hex found in:", repr(text))
        return None

    try:
        value = int(hexVal, 16)
    except ValueError:
        if DEBUG:
            print("parseGpio: bad hex:", hexVal)
        return None

    # 16-bit, LSB = io100
    bits = f"{value:016b}"[::-1]

    result = {}
    for i in range(16):
        pin = i + 100
        result[f"{pin}"] = int(bits[i])
        
    updateMass(result)

    return result
    
#############################
def updateMass(current):

    output = json.dumps(current)
    fileName = sidraCore.MASS_DIR + "/" + name + sidraCore.STATE_EXTENSION_MASS 
    sidraCore.writeFile(fileName, output)

#############################
def handleSignal(signum, frame):
    global tnConn

    if DEBUG:
        print(f"handleSignal: received signal {signum}", flush=True)

    if tnConn is not None:
        try:
            if DEBUG:
                print("handleSignal: sending 'gpio notify off' and closing telnet", flush=True)
            try:
                sendLine(tnConn, "gpio notify off")
                time.sleep(0.1)
            except Exception:
                pass
            try:
                tnConn.close()
            except Exception:
                pass
        finally:
            tnConn = None

    # exit cleanly (this raises SystemExit, so finally in main will still run)
    sys.exit(0)

##########################################################
if __name__ == "__main__":

    # debug so we can see what Python sees
    if DEBUG:
        print("ARGV:", sys.argv)

    parser = argparse.ArgumentParser(prog="mass")
    parser.add_argument(
        "name",
        nargs="?",
        default=""
    )

    args = parser.parse_args()

    name = args.name

    for mass in sidraCore.massSensors:
        #print(name)
        #print(mass["name"])
        #print(mass["ip"])
        #print(mass["lane"])
        if mass["name"] == name:
            name = mass["name"]
            lane = mass["lane"]
            ip = mass["ip"]
            print(mass)

    if DEBUG:
        print(f"Connecting to Numato GPIO @ {ip}:23")

    tnConn = None

    try:
        tnConn = telnetlib.Telnet(ip, PORT, timeout=5)

        # explicitly own both SIGINT (^C) and SIGHUP
        signal.signal(signal.SIGINT, handleSignal)
        signal.signal(signal.SIGHUP, handleSignal)

        login(tnConn)
        setAllInputsAndNotify(tnConn)
        monitorNotifications(tnConn)

    except KeyboardInterrupt:
        # This might still happen if SIGINT is not delivered for some reason
        if DEBUG:
            print("\nCtrl+C received (KeyboardInterrupt), cleaning up...", flush=True)

    finally:
        # Final safety net: if for any reason tnConn is still open, close it here.
        if tnConn is not None:
            if DEBUG:
                print("main: cleaning up telnet (finally)...", flush=True)
            try:
                sendLine(tnConn, "gpio notify off")
                time.sleep(0.1)
            except Exception:
                pass
            try:
                tnConn.close()
            except Exception:
                pass
            tnConn = None