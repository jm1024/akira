#!/usr/bin/env python3
import os
import socket
import threading
import time
import traceback

import sidraCore

PORT = 2060
MON_DIR = "/var/sidra/rts"
SCAN_INTERVAL_SECONDS = 0.01
BUFFER_SIZE = 4096
DEBUG = True

clients = set()
clientsLock = threading.Lock()


#############################
def log(message):
	if DEBUG:
		print(message, flush=True)


#############################
def broadcastFile(filePath):
	"""Read a file and send its contents to all connected clients."""
	
	data = sidraCore.readFile(filePath)
	
	if not data:
		log(f"File {filePath} is empty, skipping broadcast")
		return
	
	# Ensure we always send bytes
	if isinstance(data, str):
		dataBytes = data.encode("utf-8")
	else:
		dataBytes = data  # assume it's already bytes
	
	log(f"Broadcasting file: {filePath} ({len(dataBytes)} bytes)")
	
	deadClients = []
	
	with clientsLock:
		for clientSocket in clients:
			try:
				clientSocket.sendall(dataBytes)
			except Exception as e:
				log(f"Error sending to client {clientSocket}: {e}")
				deadClients.append(clientSocket)
	
		for clientSocket in deadClients:
			try:
				clientSocket.close()
			except Exception:
				pass
			clients.remove(clientSocket)
			log(f"Removed dead client {clientSocket}")


#############################
def handleClientMessage(clientSocket, clientAddr, data):
	"""
	Handle a single chunk of data received from a client.
	Right now we just log it; you can add JSON parsing, commands, etc.
	"""
	try:
		# try to decode as UTF-8 text; fall back to repr
		try:
			text = data.decode("utf-8", errors="replace")
			log(f"From {clientAddr}: {text!r}")
		except Exception:
			log(f"From {clientAddr} (raw bytes): {data!r}")
		
		# TODO: parse commands here if needed
		# e.g. if text.startswith("PING"): ...
	except Exception as e:
		log(f"Error in handleClientMessage from {clientAddr}: {e}")
		traceback.print_exc()


#############################
def clientLoop(clientSocket, clientAddr):
	"""
	Per-client thread: receive data from this client until it disconnects.
	"""
	log(f"Client thread started for {clientAddr}")
	
	with clientsLock:
		clients.add(clientSocket)
	
	try:
		while True:
			data = clientSocket.recv(BUFFER_SIZE)
			if not data:
				# client closed connection
				log(f"Client {clientAddr} disconnected")
				break
			
			handleClientMessage(clientSocket, clientAddr, data)
	
	except Exception as e:
		log(f"Error in clientLoop for {clientAddr}: {e}")
		traceback.print_exc()
	
	finally:
		with clientsLock:
			if clientSocket in clients:
				try:
					clientSocket.close()
				except Exception:
					pass
				clients.remove(clientSocket)
		log(f"Client thread exiting for {clientAddr}")


#############################
def watchStreamDir():
	"""Poll STREAM_DIR for new files, broadcast them, then delete them."""
	if not os.path.isdir(STREAM_DIR):
		log(f"Stream directory {STREAM_DIR} does not exist, creating it")
		try:
			os.makedirs(STREAM_DIR, exist_ok=True)
		except Exception as e:
			log(f"Failed to create directory {STREAM_DIR}: {e}")
			return

	log(f"Watching directory: {STREAM_DIR}")

	while True:
		try:
			files = sorted(os.listdir(STREAM_DIR))

			for fileName in files:
				filePath = os.path.join(STREAM_DIR, fileName)
				if not os.path.isfile(filePath):
					continue

				broadcastFile(filePath)

				# delete the file immediately
				try:
					os.remove(filePath)
					log(f"Deleted file: {filePath}")
				except Exception as e:
					log(f"Error deleting file {filePath}: {e}")

		except Exception as e:
			log(f"Error while watching directory: {e}")
			traceback.print_exc()

		time.sleep(SCAN_INTERVAL_SECONDS)


#############################
def acceptConnections(serverSocket):
	"""Accept incoming TCP connections and spawn a thread for each client."""
	log(f"Server listening on port {PORT}")
	while True:
		clientSocket, clientAddr = serverSocket.accept()
		log(f"New client connected from {clientAddr}")
		clientSocket.setblocking(True)
		
		t = threading.Thread(
			target=clientLoop,
			args=(clientSocket, clientAddr),
			daemon=True
		)
		t.start()


#############################
def main():
	serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	serverSocket.bind(("", PORT))
	serverSocket.listen(5)

	watcherThread = threading.Thread(target=watchStreamDir, daemon=True)
	watcherThread.start()

	try:
		acceptConnections(serverSocket)
	except KeyboardInterrupt:
		log("KeyboardInterrupt received, shutting down...")
	finally:
		try:
			serverSocket.close()
		except Exception:
			pass

		with clientsLock:
			for clientSocket in clients:
				try:
					clientSocket.close()
				except Exception:
					pass
			clients.clear()

		log("Server shut down cleanly")


#############################
if __name__ == "__main__":
	main()