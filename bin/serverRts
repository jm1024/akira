#!/usr/bin/env python3
import os
import socket
import threading
import time
import traceback

PORT = 2060
STREAM_DIR = "/var/sidra/stream"
SCAN_INTERVAL_SECONDS = 0.01
BUFFER_SIZE = 4096
DEBUG = True

clients = set()
clientsLock = threading.Lock()


#############################
def log(message):
	if DEBUG:
		print(message, flush=True)


#############################
def broadcastFile(filePath):
	"""Read a file and send its contents to all connected clients."""
	try:
		with open(filePath, "rb") as f:
			data = f.read()
	except Exception as e:
		log(f"Error reading file {filePath}: {e}")
		traceback.print_exc()
		return

	if not data:
		log(f"File {filePath} is empty, skipping broadcast")
		return

	log(f"Broadcasting file: {filePath} ({len(data)} bytes)")

	deadClients = []

	with clientsLock:
		for clientSocket in clients:
			try:
				clientSocket.sendall(data)
			except Exception as e:
				log(f"Error sending to client {clientSocket}: {e}")
				deadClients.append(clientSocket)

		for clientSocket in deadClients:
			try:
				clientSocket.close()
			except Exception:
				pass
			clients.remove(clientSocket)
			log(f"Removed dead client {clientSocket}")

#############################
def watchStreamDir():
	"""Poll STREAM_DIR for new files, broadcast them, then delete them."""
	if not os.path.isdir(STREAM_DIR):
		log(f"Stream directory {STREAM_DIR} does not exist, creating it")
		try:
			os.makedirs(STREAM_DIR, exist_ok=True)
		except Exception as e:
			log(f"Failed to create directory {STREAM_DIR}: {e}")
			return

	log(f"Watching directory: {STREAM_DIR}")

	while True:
		try:
			files = sorted(os.listdir(STREAM_DIR))

			for fileName in files:
				filePath = os.path.join(STREAM_DIR, fileName)
				if not os.path.isfile(filePath):
					continue

				broadcastFile(filePath)

				# delete the file immediately
				try:
					os.remove(filePath)
					log(f"Deleted file: {filePath}")
				except Exception as e:
					log(f"Error deleting file {filePath}: {e}")

		except Exception as e:
			log(f"Error while watching directory: {e}")
			traceback.print_exc()

		time.sleep(SCAN_INTERVAL_SECONDS)
		
#############################
def watchStreamDirX():
	"""Poll STREAM_DIR for new files, broadcast once, then delete them."""
	if not os.path.isdir(STREAM_DIR):
		log(f"Stream directory {STREAM_DIR} does not exist, creating it")
		try:
			os.makedirs(STREAM_DIR, exist_ok=True)
		except Exception as e:
			log(f"Failed to create directory {STREAM_DIR}: {e}")
			return

	seenFiles = set()
	log(f"Watching directory: {STREAM_DIR}")

	while True:
		try:
			currentFiles = set(os.listdir(STREAM_DIR))
			currentFiles = {
				f for f in currentFiles
				if os.path.isfile(os.path.join(STREAM_DIR, f))
			}

			newFiles = currentFiles - seenFiles

			for fileName in sorted(newFiles):
				filePath = os.path.join(STREAM_DIR, fileName)
				broadcastFile(filePath)

				# delete after transmission
				try:
					os.remove(filePath)
					log(f"Deleted file: {filePath}")
				except FileNotFoundError:
					# someone else already removed it, ignore
					pass
				except Exception as e:
					log(f"Error deleting file {filePath}: {e}")
					traceback.print_exc()

			seenFiles |= newFiles

		except Exception as e:
			log(f"Error while watching directory: {e}")
			traceback.print_exc()

		time.sleep(SCAN_INTERVAL_SECONDS)


#############################
def acceptConnections(serverSocket):
	"""Accept incoming TCP connections and track them in the global client set."""
	log(f"Server listening on port {PORT}")
	while True:
		clientSocket, clientAddr = serverSocket.accept()
		log(f"New client connected from {clientAddr}")
		clientSocket.setblocking(True)

		with clientsLock:
			clients.add(clientSocket)


#############################
def main():
	serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	serverSocket.bind(("", PORT))
	serverSocket.listen(5)

	watcherThread = threading.Thread(target=watchStreamDir, daemon=True)
	watcherThread.start()

	try:
		acceptConnections(serverSocket)
	except KeyboardInterrupt:
		log("KeyboardInterrupt received, shutting down...")
	finally:
		try:
			serverSocket.close()
		except Exception:
			pass

		with clientsLock:
			for clientSocket in clients:
				try:
					clientSocket.close()
				except Exception:
					pass
			clients.clear()

		log("Server shut down cleanly")


#############################
if __name__ == "__main__":
	main()